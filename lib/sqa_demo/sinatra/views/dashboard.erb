<div class="dashboard">
  <div class="dashboard-header">
    <div class="ticker-info">
      <h1><%= @ticker %></h1>
      <div id="priceInfo" class="price-info">
        <span class="current-price">Loading...</span>
        <span class="price-change">--</span>
      </div>
    </div>
    <div class="header-actions">
      <button onclick="location.href='/analyze/<%= @ticker %>'" class="btn btn-secondary">
        <i class="fas fa-analytics"></i> Analysis
      </button>
      <button onclick="location.href='/backtest/<%= @ticker %>'" class="btn btn-secondary">
        <i class="fas fa-history"></i> Backtest
      </button>
      <button onclick="refreshData()" class="btn btn-secondary">
        <i class="fas fa-sync-alt"></i> Refresh
      </button>
    </div>
  </div>

  <!-- Key Metrics Cards -->
  <div class="metrics-grid">
    <div class="metric-card">
      <div class="metric-label">52-Week High</div>
      <div id="high52w" class="metric-value">--</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">52-Week Low</div>
      <div id="low52w" class="metric-value">--</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Current RSI</div>
      <div id="currentRSI" class="metric-value">--</div>
      <div id="rsiSignal" class="metric-signal"></div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Market Regime</div>
      <div id="marketRegime" class="metric-value">--</div>
      <div id="regimeDetail" class="metric-signal"></div>
    </div>
  </div>

  <!-- Time Period Selector -->
  <div class="period-selector">
    <label>Time Period:</label>
    <div class="period-buttons">
      <button onclick="updatePeriod('30d')" class="btn-period" data-period="30d">30 Days</button>
      <button onclick="updatePeriod('60d')" class="btn-period" data-period="60d">60 Days</button>
      <button onclick="updatePeriod('90d')" class="btn-period active" data-period="90d">90 Days</button>
      <button onclick="updatePeriod('1q')" class="btn-period" data-period="1q">1 Quarter</button>
      <button onclick="updatePeriod('2q')" class="btn-period" data-period="2q">2 Quarters</button>
      <button onclick="updatePeriod('3q')" class="btn-period" data-period="3q">3 Quarters</button>
      <button onclick="updatePeriod('4q')" class="btn-period" data-period="4q">4 Quarters</button>
      <button onclick="updatePeriod('all')" class="btn-period" data-period="all">All Data</button>
    </div>
  </div>

  <!-- Main Price Chart -->
  <div class="chart-container">
    <div class="chart-header">
      <h2><i class="fas fa-chart-candlestick"></i> Price Chart</h2>
      <div class="chart-controls">
        <button onclick="updateChartType('candlestick')" class="btn-small active" data-chart="candlestick">
          Candlestick
        </button>
        <button onclick="updateChartType('line')" class="btn-small" data-chart="line">
          Line
        </button>
        <div id="indicatorSelector" class="indicator-selector" style="display: none;">
          <label>Indicators:</label>
          <div class="indicator-dropdown">
            <button type="button" class="btn-small dropdown-toggle" onclick="toggleIndicatorDropdown()">
              <span id="selectedIndicatorCount">None</span> <i class="fas fa-chevron-down"></i>
            </button>
            <div id="indicatorDropdownMenu" class="dropdown-menu">
              <label class="dropdown-item">
                <input type="checkbox" value="sma_12" onchange="updateSelectedIndicators()"> SMA 12
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="sma_20" onchange="updateSelectedIndicators()"> SMA 20
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="sma_50" onchange="updateSelectedIndicators()"> SMA 50
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="ema_20" onchange="updateSelectedIndicators()"> EMA 20
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="bb_upper" onchange="updateSelectedIndicators()"> BB Upper
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="bb_middle" onchange="updateSelectedIndicators()"> BB Middle
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="bb_lower" onchange="updateSelectedIndicators()"> BB Lower
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="priceChart" class="chart"></div>
  </div>

  <!-- Volume Chart -->
  <div class="chart-container">
    <div class="chart-header">
      <h2><i class="fas fa-chart-bar"></i> Volume</h2>
      <div class="chart-controls">
        <div class="chart-legend">
          <span class="legend-item"><span class="legend-color" style="background-color: #00ff88;"></span> Price Up</span>
          <span class="legend-item"><span class="legend-color" style="background-color: #ff3366;"></span> Price Down</span>
        </div>
        <div class="indicator-selector">
          <label>Indicators:</label>
          <div class="indicator-dropdown">
            <button type="button" class="btn-small dropdown-toggle" onclick="toggleVolumeIndicatorDropdown()">
              <span id="selectedVolumeIndicatorCount">None</span> <i class="fas fa-chevron-down"></i>
            </button>
            <div id="volumeIndicatorDropdownMenu" class="dropdown-menu">
              <label class="dropdown-item">
                <input type="checkbox" value="vol_sma_12" onchange="updateSelectedVolumeIndicators()"> SMA 12
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="vol_sma_20" onchange="updateSelectedVolumeIndicators()"> SMA 20
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="vol_sma_50" onchange="updateSelectedVolumeIndicators()"> SMA 50
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="vol_ema_12" onchange="updateSelectedVolumeIndicators()"> EMA 12
              </label>
              <label class="dropdown-item">
                <input type="checkbox" value="vol_ema_20" onchange="updateSelectedVolumeIndicators()"> EMA 20
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="volumeChart" class="chart"></div>
  </div>

  <!-- Technical Indicators Grid -->
  <div class="indicators-grid">
    <!-- RSI Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-wave-square"></i> RSI (14)</h3>
      </div>
      <div id="rsiChart" class="chart chart-small"></div>
    </div>

    <!-- MACD Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-signal"></i> MACD</h3>
      </div>
      <div id="macdChart" class="chart chart-small"></div>
    </div>
  </div>

  <!-- Strategy Comparison -->
  <div class="chart-container">
    <div class="chart-header">
      <h2><i class="fas fa-trophy"></i> Strategy Comparison</h2>
      <button onclick="runStrategyComparison()" class="btn btn-primary">
        <i class="fas fa-play"></i> Compare Strategies
      </button>
    </div>
    <div id="strategyResults" class="strategy-results">
      <p class="hint">Click "Compare Strategies" to see backtest results for different trading strategies.</p>
    </div>
  </div>
</div>

<script>
const ticker = '<%= @ticker %>';
let stockData = null;
let indicatorData = null;
let currentChartType = 'candlestick';
let currentPeriod = '90d';  // Default to 90 days to avoid performance issues

// ApexCharts instances
let priceChart = null;
let volumeChart = null;
let rsiChart = null;
let macdChart = null;

// Indicator configuration
const INDICATOR_CONFIG = {
  sma_12: { name: 'SMA 12', color: '#4ecdc4' },
  sma_20: { name: 'SMA 20', color: '#ffaa00' },
  sma_50: { name: 'SMA 50', color: '#ff66ff' },
  ema_20: { name: 'EMA 20', color: '#00ff88' },
  bb_upper: { name: 'BB Upper', color: '#ff6b6b' },
  bb_middle: { name: 'BB Middle', color: '#ffd93d' },
  bb_lower: { name: 'BB Lower', color: '#6bcb77' }
};

// Volume indicator configuration (same indicators but for volume data)
const VOLUME_INDICATOR_CONFIG = {
  vol_sma_12: { name: 'SMA 12', color: '#4ecdc4', period: 12, type: 'sma' },
  vol_sma_20: { name: 'SMA 20', color: '#ffaa00', period: 20, type: 'sma' },
  vol_sma_50: { name: 'SMA 50', color: '#ff66ff', period: 50, type: 'sma' },
  vol_ema_12: { name: 'EMA 12', color: '#00d4ff', period: 12, type: 'ema' },
  vol_ema_20: { name: 'EMA 20', color: '#00ff88', period: 20, type: 'ema' }
};

let selectedIndicators = [];  // User-selected indicators for line chart
let selectedVolumeIndicators = [];  // User-selected indicators for volume chart

// Calculate SMA for an array of values
function calculateSMA(data, period) {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      let sum = 0;
      for (let j = 0; j < period; j++) {
        sum += data[i - j];
      }
      result.push(sum / period);
    }
  }
  return result;
}

// Calculate EMA for an array of values
function calculateEMA(data, period) {
  const result = [];
  const multiplier = 2 / (period + 1);

  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else if (i === period - 1) {
      // First EMA is SMA
      let sum = 0;
      for (let j = 0; j < period; j++) {
        sum += data[i - j];
      }
      result.push(sum / period);
    } else {
      // EMA = (Close - Previous EMA) * multiplier + Previous EMA
      const ema = (data[i] - result[i - 1]) * multiplier + result[i - 1];
      result.push(ema);
    }
  }
  return result;
}

// Load data when page loads
document.addEventListener('DOMContentLoaded', async function() {
  await loadStockData();
  await loadIndicators();
  await loadAnalysis();
});

async function loadStockData() {
  try {
    const response = await fetch(`/api/stock/${ticker}?period=${currentPeriod}`);
    stockData = await response.json();

    // Update price info
    document.querySelector('.current-price').textContent = `$${stockData.current_price.toFixed(2)}`;

    const changeClass = stockData.change >= 0 ? 'positive' : 'negative';
    const changeSign = stockData.change >= 0 ? '+' : '';
    document.querySelector('.price-change').className = `price-change ${changeClass}`;
    document.querySelector('.price-change').textContent =
      `${changeSign}${stockData.change.toFixed(2)} (${changeSign}${stockData.change_percent.toFixed(2)}%)`;

    // Update metrics
    document.getElementById('high52w').textContent = `$${stockData.high_52w.toFixed(2)}`;
    document.getElementById('low52w').textContent = `$${stockData.low_52w.toFixed(2)}`;

    // Render charts
    renderPriceChart();
    renderVolumeChart();
  } catch (error) {
    console.error('Error loading stock data:', error);
    alert('Failed to load stock data. Please try again.');
  }
}

async function loadIndicators() {
  try {
    const response = await fetch(`/api/indicators/${ticker}?period=${currentPeriod}`);
    const data = await response.json();

    // Check if API returned an error
    if (data.error) {
      console.warn('Indicators not available:', data.error);
      document.getElementById('currentRSI').textContent = 'N/A';
      document.getElementById('rsiSignal').textContent = 'TA-Lib not installed';
      document.getElementById('rsiSignal').className = 'metric-signal';
      return;
    }

    indicatorData = data;

    // Update RSI metric
    const currentRSI = indicatorData.rsi[indicatorData.rsi.length - 1];
    document.getElementById('currentRSI').textContent = currentRSI.toFixed(2);

    let rsiSignal = '';
    let rsiClass = '';
    if (currentRSI < 30) {
      rsiSignal = 'Oversold';
      rsiClass = 'signal-buy';
    } else if (currentRSI > 70) {
      rsiSignal = 'Overbought';
      rsiClass = 'signal-sell';
    } else {
      rsiSignal = 'Neutral';
      rsiClass = 'signal-neutral';
    }
    const rsiSignalEl = document.getElementById('rsiSignal');
    rsiSignalEl.textContent = rsiSignal;
    rsiSignalEl.className = `metric-signal ${rsiClass}`;

    // Render indicator charts
    renderRSIChart();
    renderMACDChart();

    // Re-render price chart if in line mode (to include updated indicator data)
    if (currentChartType === 'line') {
      renderPriceChart();
    }

    // Re-render volume chart if volume indicators are selected
    if (selectedVolumeIndicators.length > 0) {
      renderVolumeChart();
    }
  } catch (error) {
    console.error('Error loading indicators:', error);
    document.getElementById('currentRSI').textContent = 'Error';
    document.getElementById('rsiSignal').textContent = 'Failed to load';
  }
}

async function loadAnalysis() {
  try {
    const response = await fetch(`/api/analyze/${ticker}`);
    const analysis = await response.json();

    // Update market regime
    const regime = analysis.regime.type.toUpperCase();
    const regimeEl = document.getElementById('marketRegime');
    regimeEl.textContent = regime;

    let regimeClass = '';
    if (regime === 'BULL') regimeClass = 'signal-buy';
    else if (regime === 'BEAR') regimeClass = 'signal-sell';
    else regimeClass = 'signal-neutral';
    regimeEl.className = `metric-value ${regimeClass}`;

    const regimeDetail = document.getElementById('regimeDetail');
    const strengthText = typeof analysis.regime.strength === 'number'
      ? analysis.regime.strength.toFixed(2)
      : analysis.regime.strength || 'N/A';
    regimeDetail.textContent = `${analysis.regime.volatility || 'unknown'} volatility, ${strengthText} strength`;
    regimeDetail.className = 'metric-signal';
  } catch (error) {
    console.error('Error loading analysis:', error);
  }
}

function renderPriceChart() {
  // Destroy existing chart if it exists
  if (priceChart) {
    priceChart.destroy();
  }

  let options;

  if (currentChartType === 'candlestick') {
    // Prepare candlestick data
    const candleData = stockData.dates.map((date, i) => ({
      x: new Date(date),
      y: [stockData.open[i], stockData.high[i], stockData.low[i], stockData.close[i]]
    }));

    options = {
      series: [{
        name: ticker,
        data: candleData
      }],
      chart: {
        type: 'candlestick',
        height: 500,
        group: 'stock-charts',
        background: '#151b3d',
        foreColor: '#e8eaf6',
        toolbar: {
          show: true,
          tools: {
            download: true,
            zoom: true,
            zoomin: true,
            zoomout: true,
            pan: true,
            reset: true
          }
        },
        zoom: {
          enabled: true,
          type: 'x'
        }
      },
      dataLabels: {
        enabled: false  // Disable data labels for performance
      },
      plotOptions: {
        candlestick: {
          colors: {
            upward: '#00ff88',
            downward: '#ff3366'
          }
        }
      },
      xaxis: {
        type: 'datetime',
        labels: {
          style: {
            colors: '#9fa8da'
          }
        }
      },
      yaxis: {
        tooltip: {
          enabled: true
        },
        labels: {
          style: {
            colors: '#9fa8da'
          },
          formatter: (val) => '$' + val.toFixed(2)
        }
      },
      grid: {
        borderColor: '#2a3154',
        strokeDashArray: 3
      },
      theme: {
        mode: 'dark'
      },
      tooltip: {
        theme: 'dark'
      }
    };
  } else {
    // Line chart with user-selected indicators using category axis (eliminates weekend gaps)
    const series = [{
      name: ticker,
      data: stockData.close  // Just values, aligned to categories
    }];

    // Build colors and stroke widths arrays starting with price line
    const colors = ['#00d4ff'];
    const strokeWidths = [3];

    // Add selected indicators if available
    if (indicatorData) {
      selectedIndicators.forEach(indicatorKey => {
        if (indicatorData[indicatorKey] && INDICATOR_CONFIG[indicatorKey]) {
          series.push({
            name: INDICATOR_CONFIG[indicatorKey].name,
            data: indicatorData[indicatorKey]  // Nulls are ok - ApexCharts handles them
          });
          colors.push(INDICATOR_CONFIG[indicatorKey].color);
          strokeWidths.push(2);
        }
      });
    }

    options = {
      series: series,
      chart: {
        type: 'line',
        height: 500,
        group: 'stock-charts',
        background: '#151b3d',
        foreColor: '#e8eaf6',
        toolbar: {
          show: true,
          tools: {
            download: true,
            zoom: true,
            zoomin: true,
            zoomout: true,
            pan: true,
            reset: true
          }
        },
        zoom: {
          enabled: true,
          type: 'x'
        }
      },
      colors: colors,
      stroke: {
        width: strokeWidths,
        curve: 'smooth'
      },
      xaxis: {
        type: 'category',
        categories: stockData.dates,
        tickAmount: 10,  // Limit x-axis labels for readability
        labels: {
          rotate: -45,
          rotateAlways: false,
          style: {
            colors: '#9fa8da'
          },
          formatter: (val) => {
            // Format date for display (show month and day)
            if (!val) return '';
            const parts = val.split('-');
            return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : val;
          }
        }
      },
      yaxis: {
        labels: {
          style: {
            colors: '#9fa8da'
          },
          formatter: (val) => val ? '$' + val.toFixed(2) : ''
        }
      },
      grid: {
        borderColor: '#2a3154',
        strokeDashArray: 3
      },
      legend: {
        position: 'top',
        horizontalAlign: 'left',
        fontSize: '14px',
        labels: {
          colors: '#e8eaf6'
        }
      },
      theme: {
        mode: 'dark'
      },
      tooltip: {
        theme: 'dark',
        shared: true,
        intersect: false,
        x: {
          formatter: (val, opts) => {
            // Show full date in tooltip
            const date = stockData.dates[opts.dataPointIndex];
            return date || val;
          }
        }
      }
    };
  }

  priceChart = new ApexCharts(document.querySelector("#priceChart"), options);
  priceChart.render();
}

function renderVolumeChart() {
  // Destroy existing chart if it exists
  if (volumeChart) {
    volumeChart.destroy();
  }

  // Calculate bar colors based on price movement
  const barColors = stockData.volume.map((vol, i) =>
    i === 0 ? '#00d4ff' : (stockData.close[i] >= stockData.close[i - 1] ? '#00ff88' : '#ff3366')
  );

  // Build series array - volume bars first (plain array for mixed chart compatibility)
  // Use 'column' type for vertical bars in mixed charts
  const series = [{
    name: 'Volume',
    type: 'column',
    data: stockData.volume
  }];

  // Build stroke widths array
  const strokeWidths = [0];  // No stroke for bars

  // Build colors array for series (first is for bars, rest are for line indicators)
  // Note: Per-bar coloring is handled separately via fill options
  const seriesColors = ['#00d4ff'];  // Default bar color

  // Add selected volume indicators as line series (using backend-calculated data)
  if (indicatorData) {
    selectedVolumeIndicators.forEach(indicatorKey => {
      const config = VOLUME_INDICATOR_CONFIG[indicatorKey];
      // Map frontend key to backend data key (vol_sma_12 -> indicatorData.vol_sma_12)
      const backendData = indicatorData[indicatorKey];

      if (config && backendData) {
        series.push({
          name: config.name,
          type: 'line',
          data: backendData
        });
        strokeWidths.push(2);
        seriesColors.push(config.color);
      }
    });
  }

  const options = {
    series: series,
    chart: {
      type: 'line',  // Base type for mixed charts
      height: 300,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: {
        show: true,
        tools: {
          download: true,
          zoom: true,
          zoomin: true,
          zoomout: true,
          pan: true,
          reset: true
        }
      },
      zoom: {
        enabled: true,
        type: 'x'
      }
    },
    colors: seriesColors,
    stroke: {
      width: strokeWidths,
      curve: 'smooth'
    },
    dataLabels: {
      enabled: false  // Disable data labels for performance
    },
    plotOptions: {
      bar: {
        columnWidth: '95%',
        distributed: false
      }
    },
    fill: {
      colors: [function({ value, seriesIndex, dataPointIndex, w }) {
        if (seriesIndex === 0) {
          // Bar series - use price movement colors
          return barColors[dataPointIndex] || '#00d4ff';
        }
        // Line series - use their configured color
        return seriesColors[seriesIndex] || '#00d4ff';
      }]
    },
    xaxis: {
      type: 'category',
      categories: stockData.dates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        rotateAlways: false,
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => {
          if (!val) return '';
          const parts = val.split('-');
          return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : val;
        }
      }
    },
    yaxis: {
      labels: {
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => {
          if (val >= 1e9) return (val / 1e9).toFixed(1) + 'B';
          if (val >= 1e6) return (val / 1e6).toFixed(1) + 'M';
          if (val >= 1e3) return (val / 1e3).toFixed(1) + 'K';
          return val.toFixed(0);
        }
      }
    },
    grid: {
      borderColor: '#2a3154',
      strokeDashArray: 3
    },
    legend: {
      show: selectedVolumeIndicators.length > 0,
      position: 'top',
      horizontalAlign: 'left',
      fontSize: '14px',
      labels: {
        colors: '#e8eaf6'
      }
    },
    theme: {
      mode: 'dark'
    },
    tooltip: {
      theme: 'dark',
      shared: true,
      intersect: false,
      y: {
        formatter: (val) => val ? val.toLocaleString() : ''
      },
      x: {
        formatter: (val, opts) => stockData.dates[opts.dataPointIndex] || val
      }
    }
  };

  volumeChart = new ApexCharts(document.querySelector("#volumeChart"), options);
  volumeChart.render();
}

function renderRSIChart() {
  // Destroy existing chart if it exists
  if (rsiChart) {
    rsiChart.destroy();
  }

  // Skip if indicators not available
  if (!indicatorData || !indicatorData.rsi) {
    document.querySelector("#rsiChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">Technical indicators not available (TA-Lib required)</p>';
    return;
  }

  // Filter out null/NaN/undefined values and build category-aligned data
  const validDates = [];
  const validRSI = [];
  for (let i = 0; i < indicatorData.rsi.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.dates[i] !== undefined &&
        indicatorData.rsi[i] !== null &&
        indicatorData.rsi[i] !== undefined &&
        !isNaN(indicatorData.rsi[i])) {
      validDates.push(indicatorData.dates[i]);
      validRSI.push(indicatorData.rsi[i]);
    }
  }

  // If no valid data, show message
  if (validDates.length === 0) {
    document.querySelector("#rsiChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid RSI data available (warmup period or data issue)</p>';
    return;
  }

  // Create constant arrays for reference lines
  const oversoldLine = validDates.map(() => 30);
  const overboughtLine = validDates.map(() => 70);

  const options = {
    series: [
      { name: 'RSI', data: validRSI },
      { name: 'Oversold (30)', data: oversoldLine },
      { name: 'Overbought (70)', data: overboughtLine }
    ],
    chart: {
      type: 'line',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: {
        show: true,
        tools: {
          download: true,
          zoom: true,
          zoomin: true,
          zoomout: true,
          pan: true,
          reset: true
        }
      },
      zoom: {
        enabled: true,
        type: 'x'
      }
    },
    colors: ['#00d4ff', '#00ff88', '#ff3366'],
    stroke: {
      width: [3, 2, 2],
      curve: 'smooth',
      dashArray: [0, 5, 5]
    },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        rotateAlways: false,
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => {
          if (!val) return '';
          const parts = val.split('-');
          return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : val;
        }
      }
    },
    yaxis: {
      min: 0,
      max: 100,
      labels: {
        style: {
          colors: '#9fa8da'
        }
      }
    },
    grid: {
      borderColor: '#2a3154',
      strokeDashArray: 3
    },
    legend: {
      position: 'top',
      horizontalAlign: 'left',
      fontSize: '14px',
      labels: {
        colors: '#e8eaf6'
      }
    },
    theme: {
      mode: 'dark'
    },
    tooltip: {
      theme: 'dark',
      shared: true,
      intersect: false,
      x: {
        formatter: (val, opts) => validDates[opts.dataPointIndex] || val
      }
    },
    annotations: {
      yaxis: [
        {
          y: 30,
          borderColor: '#00ff88',
          fillColor: '#00ff88',
          opacity: 0.1
        },
        {
          y: 70,
          borderColor: '#ff3366',
          fillColor: '#ff3366',
          opacity: 0.1
        }
      ]
    }
  };

  rsiChart = new ApexCharts(document.querySelector("#rsiChart"), options);
  rsiChart.render();
}

function renderMACDChart() {
  // Destroy existing chart if it exists
  if (macdChart) {
    macdChart.destroy();
  }

  // Skip if indicators not available
  if (!indicatorData || !indicatorData.macd) {
    document.querySelector("#macdChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">Technical indicators not available (TA-Lib required)</p>';
    return;
  }

  // Filter out null/NaN/undefined values and build category-aligned data
  const validDates = [];
  const validMACD = [];
  const validSignal = [];
  const validHist = [];
  for (let i = 0; i < indicatorData.macd.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.dates[i] !== undefined &&
        indicatorData.macd[i] !== null &&
        indicatorData.macd[i] !== undefined &&
        indicatorData.macd_signal[i] !== null &&
        indicatorData.macd_signal[i] !== undefined &&
        indicatorData.macd_hist[i] !== null &&
        indicatorData.macd_hist[i] !== undefined &&
        !isNaN(indicatorData.macd[i]) &&
        !isNaN(indicatorData.macd_signal[i]) &&
        !isNaN(indicatorData.macd_hist[i])) {
      validDates.push(indicatorData.dates[i]);
      validMACD.push(indicatorData.macd[i]);
      validSignal.push(indicatorData.macd_signal[i]);
      validHist.push(indicatorData.macd_hist[i]);
    }
  }

  // If no valid data, show message
  if (validDates.length === 0) {
    document.querySelector("#macdChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid MACD data available (warmup period or data issue)</p>';
    return;
  }

  // Prepare histogram data with colors for category axis
  const histData = validHist.map(h => ({
    y: h,
    fillColor: h >= 0 ? '#00ff88' : '#ff3366'
  }));

  const options = {
    series: [
      { name: 'Histogram', type: 'bar', data: histData },
      { name: 'MACD', type: 'line', data: validMACD },
      { name: 'Signal', type: 'line', data: validSignal }
    ],
    chart: {
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: {
        show: true,
        tools: {
          download: true,
          zoom: true,
          zoomin: true,
          zoomout: true,
          pan: true,
          reset: true
        }
      },
      zoom: {
        enabled: true,
        type: 'x'
      }
    },
    plotOptions: {
      bar: {
        columnWidth: '80%'
      }
    },
    colors: ['#00ff88', '#00d4ff', '#ffaa00'],
    stroke: {
      width: [0, 3, 3],
      curve: 'smooth'
    },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        rotateAlways: false,
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => {
          if (!val) return '';
          const parts = val.split('-');
          return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : val;
        }
      }
    },
    yaxis: {
      labels: {
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => val ? val.toFixed(2) : ''
      }
    },
    grid: {
      borderColor: '#2a3154',
      strokeDashArray: 3
    },
    legend: {
      position: 'top',
      horizontalAlign: 'left',
      fontSize: '14px',
      labels: {
        colors: '#e8eaf6'
      }
    },
    theme: {
      mode: 'dark'
    },
    tooltip: {
      theme: 'dark',
      shared: true,
      intersect: false,
      x: {
        formatter: (val, opts) => validDates[opts.dataPointIndex] || val
      }
    }
  };

  macdChart = new ApexCharts(document.querySelector("#macdChart"), options);
  macdChart.render();
}

function updateChartType(type) {
  currentChartType = type;

  // Update button states
  document.querySelectorAll('[data-chart]').forEach(btn => {
    btn.classList.remove('active');
  });
  document.querySelector(`[data-chart="${type}"]`).classList.add('active');

  // Show/hide indicator selector based on chart type
  const indicatorSelector = document.getElementById('indicatorSelector');
  indicatorSelector.style.display = type === 'line' ? 'flex' : 'none';

  // Re-render chart
  renderPriceChart();
}

function toggleIndicatorDropdown() {
  const menu = document.getElementById('indicatorDropdownMenu');
  menu.classList.toggle('show');
}

function updateSelectedIndicators() {
  const checkboxes = document.querySelectorAll('#indicatorDropdownMenu input[type="checkbox"]');
  selectedIndicators = [];

  checkboxes.forEach(cb => {
    if (cb.checked) {
      selectedIndicators.push(cb.value);
    }
  });

  // Update the count display
  const countEl = document.getElementById('selectedIndicatorCount');
  if (selectedIndicators.length === 0) {
    countEl.textContent = 'None';
  } else if (selectedIndicators.length === 1) {
    countEl.textContent = INDICATOR_CONFIG[selectedIndicators[0]].name;
  } else {
    countEl.textContent = `${selectedIndicators.length} selected`;
  }

  // Re-render the chart if in line mode
  if (currentChartType === 'line') {
    renderPriceChart();
  }
}

function toggleVolumeIndicatorDropdown() {
  const menu = document.getElementById('volumeIndicatorDropdownMenu');
  menu.classList.toggle('show');
}

function updateSelectedVolumeIndicators() {
  const checkboxes = document.querySelectorAll('#volumeIndicatorDropdownMenu input[type="checkbox"]');
  selectedVolumeIndicators = [];

  checkboxes.forEach(cb => {
    if (cb.checked) {
      selectedVolumeIndicators.push(cb.value);
    }
  });

  // Update the count display
  const countEl = document.getElementById('selectedVolumeIndicatorCount');
  if (selectedVolumeIndicators.length === 0) {
    countEl.textContent = 'None';
  } else if (selectedVolumeIndicators.length === 1) {
    countEl.textContent = VOLUME_INDICATOR_CONFIG[selectedVolumeIndicators[0]].name;
  } else {
    countEl.textContent = `${selectedVolumeIndicators.length} selected`;
  }

  // Re-render the volume chart
  renderVolumeChart();
}

// Close dropdowns when clicking outside
document.addEventListener('click', function(event) {
  const priceDropdown = document.querySelector('#indicatorSelector .indicator-dropdown');
  if (priceDropdown && !priceDropdown.contains(event.target)) {
    document.getElementById('indicatorDropdownMenu').classList.remove('show');
  }

  const volumeDropdown = document.querySelector('#volumeIndicatorDropdownMenu')?.closest('.indicator-dropdown');
  if (volumeDropdown && !volumeDropdown.contains(event.target)) {
    document.getElementById('volumeIndicatorDropdownMenu').classList.remove('show');
  }
});

async function runStrategyComparison() {
  const resultsDiv = document.getElementById('strategyResults');
  resultsDiv.innerHTML = '<p class="loading"><i class="fas fa-spinner fa-spin"></i> Running backtests...</p>';

  try {
    const response = await fetch(`/api/compare/${ticker}`, { method: 'POST' });
    const results = await response.json();

    let html = '<table class="results-table"><thead><tr>';
    html += '<th>Strategy</th><th>Return</th><th>Sharpe</th><th>Drawdown</th><th>Win Rate</th><th>Trades</th>';
    html += '</tr></thead><tbody>';

    results.forEach((result, i) => {
      const returnClass = result.return >= 0 ? 'positive' : 'negative';
      const rank = i === 0 ? '<i class="fas fa-trophy" style="color: #FFD700;"></i> ' : '';
      html += `<tr>
        <td>${rank}${result.strategy}</td>
        <td class="${returnClass}">${result.return.toFixed(2)}%</td>
        <td>${result.sharpe.toFixed(2)}</td>
        <td>${result.drawdown.toFixed(2)}%</td>
        <td>${result.win_rate.toFixed(2)}%</td>
        <td>${result.trades}</td>
      </tr>`;
    });

    html += '</tbody></table>';
    resultsDiv.innerHTML = html;
  } catch (error) {
    console.error('Error comparing strategies:', error);
    resultsDiv.innerHTML = '<p class="error">Failed to compare strategies. Please try again.</p>';
  }
}

async function updatePeriod(period) {
  currentPeriod = period;

  // Update button states
  document.querySelectorAll('[data-period]').forEach(btn => {
    btn.classList.remove('active');
  });
  document.querySelector(`[data-period="${period}"]`).classList.add('active');

  // Reload data with new period
  await loadStockData();
  await loadIndicators();
}

function refreshData() {
  location.reload();
}
</script>
