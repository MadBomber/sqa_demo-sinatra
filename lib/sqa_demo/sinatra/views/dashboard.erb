<div class="dashboard">
  <div class="dashboard-header">
    <div class="ticker-info">
      <h1><%= @ticker %></h1>
      <div id="priceInfo" class="price-info">
        <span class="current-price">Loading...</span>
        <span class="price-change">--</span>
      </div>
    </div>
    <div class="header-actions">
      <button onclick="location.href='/analyze/<%= @ticker %>'" class="btn btn-secondary">
        <i class="fas fa-analytics"></i> Analysis
      </button>
      <button onclick="location.href='/backtest/<%= @ticker %>'" class="btn btn-secondary">
        <i class="fas fa-history"></i> Backtest
      </button>
      <button onclick="refreshData()" class="btn btn-secondary">
        <i class="fas fa-sync-alt"></i> Refresh
      </button>
    </div>
  </div>

  <!-- Key Metrics Cards -->
  <div class="metrics-grid">
    <div class="metric-card">
      <div class="metric-label">52-Week High</div>
      <div id="high52w" class="metric-value">--</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">52-Week Low</div>
      <div id="low52w" class="metric-value">--</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Current RSI</div>
      <div id="currentRSI" class="metric-value">--</div>
      <div id="rsiSignal" class="metric-signal"></div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Market Regime</div>
      <div id="marketRegime" class="metric-value">--</div>
      <div id="regimeDetail" class="metric-signal"></div>
    </div>
  </div>

  <!-- Time Period Selector -->
  <div class="period-selector">
    <label>Time Period:</label>
    <div class="period-buttons">
      <button onclick="updatePeriod('30d')" class="btn-period" data-period="30d">30 Days</button>
      <button onclick="updatePeriod('60d')" class="btn-period" data-period="60d">60 Days</button>
      <button onclick="updatePeriod('90d')" class="btn-period active" data-period="90d">90 Days</button>
      <button onclick="updatePeriod('1q')" class="btn-period" data-period="1q">1 Quarter</button>
      <button onclick="updatePeriod('2q')" class="btn-period" data-period="2q">2 Quarters</button>
      <button onclick="updatePeriod('3q')" class="btn-period" data-period="3q">3 Quarters</button>
      <button onclick="updatePeriod('4q')" class="btn-period" data-period="4q">4 Quarters</button>
      <button onclick="updatePeriod('all')" class="btn-period" data-period="all">All Data</button>
    </div>
  </div>

  <!-- Main Price Chart -->
  <div class="chart-container">
    <div class="chart-header">
      <h2><i class="fas fa-chart-candlestick"></i> Price Chart</h2>
      <div class="chart-controls">
        <button onclick="updateChartType('candlestick')" class="btn-small active" data-chart="candlestick">
          Candlestick
        </button>
        <button onclick="updateChartType('line')" class="btn-small" data-chart="line">
          Line
        </button>
        <div id="indicatorSelector" class="indicator-selector" style="display: none;">
          <label>Indicators:</label>
          <div class="indicator-dropdown">
            <button type="button" class="btn-small dropdown-toggle" onclick="toggleIndicatorDropdown()">
              <span id="selectedIndicatorCount">None</span> <i class="fas fa-chevron-down"></i>
            </button>
            <div id="indicatorDropdownMenu" class="dropdown-menu dropdown-menu-scrollable">
              <div class="dropdown-section">
                <div class="dropdown-section-title">Simple MA</div>
                <label class="dropdown-item">
                  <input type="checkbox" value="sma_12" onchange="updateSelectedIndicators()"> SMA 12
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="sma_20" onchange="updateSelectedIndicators()"> SMA 20
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="sma_50" onchange="updateSelectedIndicators()"> SMA 50
                </label>
              </div>
              <div class="dropdown-section">
                <div class="dropdown-section-title">Exponential MA</div>
                <label class="dropdown-item">
                  <input type="checkbox" value="ema_20" onchange="updateSelectedIndicators()"> EMA 20
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="dema_20" onchange="updateSelectedIndicators()"> DEMA 20
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="tema_20" onchange="updateSelectedIndicators()"> TEMA 20
                </label>
              </div>
              <div class="dropdown-section">
                <div class="dropdown-section-title">Other MA</div>
                <label class="dropdown-item">
                  <input type="checkbox" value="wma_20" onchange="updateSelectedIndicators()"> WMA 20
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="kama_30" onchange="updateSelectedIndicators()"> KAMA 30
                </label>
              </div>
              <div class="dropdown-section">
                <div class="dropdown-section-title">Bollinger Bands</div>
                <label class="dropdown-item">
                  <input type="checkbox" value="bb_upper" onchange="updateSelectedIndicators()"> BB Upper
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="bb_middle" onchange="updateSelectedIndicators()"> BB Middle
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="bb_lower" onchange="updateSelectedIndicators()"> BB Lower
                </label>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="priceChart" class="chart"></div>
  </div>

  <!-- Volume Chart -->
  <div class="chart-container">
    <div class="chart-header">
      <h2><i class="fas fa-chart-bar"></i> Volume</h2>
      <div class="chart-controls">
        <div class="chart-legend">
          <span class="legend-item"><span class="legend-color" style="background-color: #00ff88;"></span> Price Up</span>
          <span class="legend-item"><span class="legend-color" style="background-color: #ff3366;"></span> Price Down</span>
        </div>
        <div class="indicator-selector">
          <label>Indicators:</label>
          <div class="indicator-dropdown">
            <button type="button" class="btn-small dropdown-toggle" onclick="toggleVolumeIndicatorDropdown()">
              <span id="selectedVolumeIndicatorCount">None</span> <i class="fas fa-chevron-down"></i>
            </button>
            <div id="volumeIndicatorDropdownMenu" class="dropdown-menu dropdown-menu-scrollable">
              <div class="dropdown-section">
                <div class="dropdown-section-title">Moving Averages</div>
                <label class="dropdown-item">
                  <input type="checkbox" value="vol_sma_12" onchange="updateSelectedVolumeIndicators()"> SMA 12
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="vol_sma_20" onchange="updateSelectedVolumeIndicators()"> SMA 20
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="vol_sma_50" onchange="updateSelectedVolumeIndicators()"> SMA 50
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="vol_ema_12" onchange="updateSelectedVolumeIndicators()"> EMA 12
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="vol_ema_20" onchange="updateSelectedVolumeIndicators()"> EMA 20
                </label>
              </div>
              <div class="dropdown-section">
                <div class="dropdown-section-title">Volume Analysis</div>
                <label class="dropdown-item">
                  <input type="checkbox" value="obv" onchange="updateSelectedVolumeIndicators()"> OBV
                </label>
                <label class="dropdown-item">
                  <input type="checkbox" value="ad" onchange="updateSelectedVolumeIndicators()"> A/D Line
                </label>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="volumeChart" class="chart"></div>
  </div>

  <!-- Technical Indicators Grid -->
  <div class="indicators-grid">
    <!-- RSI Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-wave-square"></i> RSI (14)</h3>
      </div>
      <div id="rsiChart" class="chart chart-small"></div>
    </div>

    <!-- MACD Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-signal"></i> MACD</h3>
      </div>
      <div id="macdChart" class="chart chart-small"></div>
    </div>

    <!-- Stochastic Oscillator Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-chart-line"></i> Stochastic (5,3,3)</h3>
      </div>
      <div id="stochChart" class="chart chart-small"></div>
    </div>

    <!-- CCI Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-compress-arrows-alt"></i> CCI (14)</h3>
      </div>
      <div id="cciChart" class="chart chart-small"></div>
    </div>

    <!-- ADX Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-arrows-alt-h"></i> ADX (14)</h3>
      </div>
      <div id="adxChart" class="chart chart-small"></div>
    </div>

    <!-- Williams %R Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-percentage"></i> Williams %R (14)</h3>
      </div>
      <div id="willrChart" class="chart chart-small"></div>
    </div>

    <!-- ATR Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-expand-arrows-alt"></i> ATR (14)</h3>
      </div>
      <div id="atrChart" class="chart chart-small"></div>
    </div>

    <!-- ROC Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-tachometer-alt"></i> ROC (10)</h3>
      </div>
      <div id="rocChart" class="chart chart-small"></div>
    </div>

    <!-- Momentum Chart -->
    <div class="chart-container">
      <div class="chart-header">
        <h3><i class="fas fa-rocket"></i> Momentum (10)</h3>
      </div>
      <div id="momChart" class="chart chart-small"></div>
    </div>
  </div>

  <!-- Pattern Recognition & Signal Alerts -->
  <div class="alerts-row">
    <!-- Candlestick Patterns -->
    <div class="chart-container">
      <div class="chart-header">
        <h2><i class="fas fa-shapes"></i> Candlestick Patterns</h2>
      </div>
      <div id="patternAlerts" class="alerts-container">
        <p class="hint">Loading patterns...</p>
      </div>
    </div>

    <!-- Signal Alerts -->
    <div class="chart-container">
      <div class="chart-header">
        <h2><i class="fas fa-bell"></i> Signal Alerts</h2>
      </div>
      <div id="signalAlerts" class="alerts-container">
        <p class="hint">Loading signals...</p>
      </div>
    </div>
  </div>

  <!-- Strategy Comparison -->
  <div class="chart-container">
    <div class="chart-header">
      <h2><i class="fas fa-trophy"></i> Strategy Comparison</h2>
      <button onclick="runStrategyComparison()" class="btn btn-primary">
        <i class="fas fa-play"></i> Compare Strategies
      </button>
    </div>
    <div id="strategyResults" class="strategy-results">
      <p class="hint">Click "Compare Strategies" to see backtest results for different trading strategies.</p>
    </div>
  </div>
</div>

<script>
const ticker = '<%= @ticker %>';
let stockData = null;
let indicatorData = null;
let currentChartType = 'candlestick';
let currentPeriod = '90d';  // Default to 90 days to avoid performance issues

// ApexCharts instances
let priceChart = null;
let volumeChart = null;
let rsiChart = null;
let macdChart = null;
let stochChart = null;
let cciChart = null;
let adxChart = null;
let willrChart = null;
let atrChart = null;
let rocChart = null;
let momChart = null;

// Indicator configuration - Price Overlays
const INDICATOR_CONFIG = {
  // Simple Moving Averages
  sma_12: { name: 'SMA 12', color: '#4ecdc4' },
  sma_20: { name: 'SMA 20', color: '#ffaa00' },
  sma_50: { name: 'SMA 50', color: '#ff66ff' },
  // Exponential Moving Average
  ema_20: { name: 'EMA 20', color: '#00ff88' },
  // Additional Moving Averages
  wma_20: { name: 'WMA 20', color: '#ff9f43' },
  dema_20: { name: 'DEMA 20', color: '#a55eea' },
  tema_20: { name: 'TEMA 20', color: '#26de81' },
  kama_30: { name: 'KAMA 30', color: '#fd9644' },
  // Bollinger Bands
  bb_upper: { name: 'BB Upper', color: '#ff6b6b' },
  bb_middle: { name: 'BB Middle', color: '#ffd93d' },
  bb_lower: { name: 'BB Lower', color: '#6bcb77' }
};

// Volume indicator configuration (moving averages for volume data)
const VOLUME_INDICATOR_CONFIG = {
  vol_sma_12: { name: 'SMA 12', color: '#4ecdc4', period: 12, type: 'sma' },
  vol_sma_20: { name: 'SMA 20', color: '#ffaa00', period: 20, type: 'sma' },
  vol_sma_50: { name: 'SMA 50', color: '#ff66ff', period: 50, type: 'sma' },
  vol_ema_12: { name: 'EMA 12', color: '#00d4ff', period: 12, type: 'ema' },
  vol_ema_20: { name: 'EMA 20', color: '#00ff88', period: 20, type: 'ema' },
  obv: { name: 'OBV', color: '#a55eea', type: 'line' },
  ad: { name: 'A/D Line', color: '#26de81', type: 'line' }
};

let selectedIndicators = [];  // User-selected indicators for line chart
let selectedVolumeIndicators = [];  // User-selected indicators for volume chart

// Calculate SMA for an array of values
function calculateSMA(data, period) {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      let sum = 0;
      for (let j = 0; j < period; j++) {
        sum += data[i - j];
      }
      result.push(sum / period);
    }
  }
  return result;
}

// Calculate EMA for an array of values
function calculateEMA(data, period) {
  const result = [];
  const multiplier = 2 / (period + 1);

  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else if (i === period - 1) {
      // First EMA is SMA
      let sum = 0;
      for (let j = 0; j < period; j++) {
        sum += data[i - j];
      }
      result.push(sum / period);
    } else {
      // EMA = (Close - Previous EMA) * multiplier + Previous EMA
      const ema = (data[i] - result[i - 1]) * multiplier + result[i - 1];
      result.push(ema);
    }
  }
  return result;
}

// Load data when page loads
document.addEventListener('DOMContentLoaded', async function() {
  await loadStockData();
  await loadIndicators();
  await loadAnalysis();
});

async function loadStockData() {
  try {
    const response = await fetch(`/api/stock/${ticker}?period=${currentPeriod}`);
    stockData = await response.json();

    // Update price info
    document.querySelector('.current-price').textContent = `$${stockData.current_price.toFixed(2)}`;

    const changeClass = stockData.change >= 0 ? 'positive' : 'negative';
    const changeSign = stockData.change >= 0 ? '+' : '';
    document.querySelector('.price-change').className = `price-change ${changeClass}`;
    document.querySelector('.price-change').textContent =
      `${changeSign}${stockData.change.toFixed(2)} (${changeSign}${stockData.change_percent.toFixed(2)}%)`;

    // Update metrics
    document.getElementById('high52w').textContent = `$${stockData.high_52w.toFixed(2)}`;
    document.getElementById('low52w').textContent = `$${stockData.low_52w.toFixed(2)}`;

    // Render charts
    renderPriceChart();
    renderVolumeChart();
  } catch (error) {
    console.error('Error loading stock data:', error);
    alert('Failed to load stock data. Please try again.');
  }
}

async function loadIndicators() {
  try {
    const response = await fetch(`/api/indicators/${ticker}?period=${currentPeriod}`);
    const data = await response.json();

    // Check if API returned an error
    if (data.error) {
      console.warn('Indicators not available:', data.error);
      document.getElementById('currentRSI').textContent = 'N/A';
      document.getElementById('rsiSignal').textContent = 'TA-Lib not installed';
      document.getElementById('rsiSignal').className = 'metric-signal';
      return;
    }

    indicatorData = data;

    // Update RSI metric
    const currentRSI = indicatorData.rsi[indicatorData.rsi.length - 1];
    document.getElementById('currentRSI').textContent = currentRSI.toFixed(2);

    let rsiSignal = '';
    let rsiClass = '';
    if (currentRSI < 30) {
      rsiSignal = 'Oversold';
      rsiClass = 'signal-buy';
    } else if (currentRSI > 70) {
      rsiSignal = 'Overbought';
      rsiClass = 'signal-sell';
    } else {
      rsiSignal = 'Neutral';
      rsiClass = 'signal-neutral';
    }
    const rsiSignalEl = document.getElementById('rsiSignal');
    rsiSignalEl.textContent = rsiSignal;
    rsiSignalEl.className = `metric-signal ${rsiClass}`;

    // Render indicator charts
    renderRSIChart();
    renderMACDChart();
    renderStochChart();
    renderCCIChart();
    renderADXChart();
    renderWillrChart();
    renderATRChart();
    renderROCChart();
    renderMomentumChart();

    // Render alerts
    renderPatternAlerts();
    renderSignalAlerts();

    // Re-render price chart if in line mode (to include updated indicator data)
    if (currentChartType === 'line') {
      renderPriceChart();
    }

    // Re-render volume chart if volume indicators are selected
    if (selectedVolumeIndicators.length > 0) {
      renderVolumeChart();
    }
  } catch (error) {
    console.error('Error loading indicators:', error);
    document.getElementById('currentRSI').textContent = 'Error';
    document.getElementById('rsiSignal').textContent = 'Failed to load';
  }
}

async function loadAnalysis() {
  try {
    const response = await fetch(`/api/analyze/${ticker}`);
    const analysis = await response.json();

    // Update market regime
    const regime = analysis.regime.type.toUpperCase();
    const regimeEl = document.getElementById('marketRegime');
    regimeEl.textContent = regime;

    let regimeClass = '';
    if (regime === 'BULL') regimeClass = 'signal-buy';
    else if (regime === 'BEAR') regimeClass = 'signal-sell';
    else regimeClass = 'signal-neutral';
    regimeEl.className = `metric-value ${regimeClass}`;

    const regimeDetail = document.getElementById('regimeDetail');
    const strengthText = typeof analysis.regime.strength === 'number'
      ? analysis.regime.strength.toFixed(2)
      : analysis.regime.strength || 'N/A';
    regimeDetail.textContent = `${analysis.regime.volatility || 'unknown'} volatility, ${strengthText} strength`;
    regimeDetail.className = 'metric-signal';
  } catch (error) {
    console.error('Error loading analysis:', error);
  }
}

function renderPriceChart() {
  // Destroy existing chart if it exists
  if (priceChart) {
    priceChart.destroy();
  }

  let options;

  if (currentChartType === 'candlestick') {
    // Prepare candlestick data
    const candleData = stockData.dates.map((date, i) => ({
      x: new Date(date),
      y: [stockData.open[i], stockData.high[i], stockData.low[i], stockData.close[i]]
    }));

    options = {
      series: [{
        name: ticker,
        data: candleData
      }],
      chart: {
        type: 'candlestick',
        height: 500,
        group: 'stock-charts',
        background: '#151b3d',
        foreColor: '#e8eaf6',
        toolbar: {
          show: true,
          tools: {
            download: true,
            zoom: true,
            zoomin: true,
            zoomout: true,
            pan: true,
            reset: true
          }
        },
        zoom: {
          enabled: true,
          type: 'x'
        }
      },
      dataLabels: {
        enabled: false  // Disable data labels for performance
      },
      plotOptions: {
        candlestick: {
          colors: {
            upward: '#00ff88',
            downward: '#ff3366'
          }
        }
      },
      xaxis: {
        type: 'datetime',
        labels: {
          style: {
            colors: '#9fa8da'
          }
        }
      },
      yaxis: {
        tooltip: {
          enabled: true
        },
        labels: {
          style: {
            colors: '#9fa8da'
          },
          formatter: (val) => '$' + val.toFixed(2)
        }
      },
      grid: {
        borderColor: '#2a3154',
        strokeDashArray: 3
      },
      theme: {
        mode: 'dark'
      },
      tooltip: {
        theme: 'dark'
      }
    };
  } else {
    // Line chart with user-selected indicators using category axis (eliminates weekend gaps)
    const series = [{
      name: ticker,
      data: stockData.close  // Just values, aligned to categories
    }];

    // Build colors and stroke widths arrays starting with price line
    const colors = ['#00d4ff'];
    const strokeWidths = [3];

    // Add selected indicators if available
    if (indicatorData) {
      selectedIndicators.forEach(indicatorKey => {
        if (indicatorData[indicatorKey] && INDICATOR_CONFIG[indicatorKey]) {
          series.push({
            name: INDICATOR_CONFIG[indicatorKey].name,
            data: indicatorData[indicatorKey]  // Nulls are ok - ApexCharts handles them
          });
          colors.push(INDICATOR_CONFIG[indicatorKey].color);
          strokeWidths.push(2);
        }
      });
    }

    options = {
      series: series,
      chart: {
        type: 'line',
        height: 500,
        group: 'stock-charts',
        background: '#151b3d',
        foreColor: '#e8eaf6',
        toolbar: {
          show: true,
          tools: {
            download: true,
            zoom: true,
            zoomin: true,
            zoomout: true,
            pan: true,
            reset: true
          }
        },
        zoom: {
          enabled: true,
          type: 'x'
        }
      },
      colors: colors,
      stroke: {
        width: strokeWidths,
        curve: 'smooth'
      },
      xaxis: {
        type: 'category',
        categories: stockData.dates,
        tickAmount: 10,  // Limit x-axis labels for readability
        labels: {
          rotate: -45,
          rotateAlways: false,
          style: {
            colors: '#9fa8da'
          },
          formatter: (val) => {
            // Format date for display (show month and day)
            if (!val) return '';
            const parts = val.split('-');
            return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : val;
          }
        }
      },
      yaxis: {
        labels: {
          style: {
            colors: '#9fa8da'
          },
          formatter: (val) => val ? '$' + val.toFixed(2) : ''
        }
      },
      grid: {
        borderColor: '#2a3154',
        strokeDashArray: 3
      },
      legend: {
        position: 'top',
        horizontalAlign: 'left',
        fontSize: '14px',
        labels: {
          colors: '#e8eaf6'
        }
      },
      theme: {
        mode: 'dark'
      },
      tooltip: {
        theme: 'dark',
        shared: true,
        intersect: false,
        x: {
          formatter: (val, opts) => {
            // Show full date in tooltip
            const date = stockData.dates[opts.dataPointIndex];
            return date || val;
          }
        }
      }
    };
  }

  priceChart = new ApexCharts(document.querySelector("#priceChart"), options);
  priceChart.render();
}

function renderVolumeChart() {
  // Destroy existing chart if it exists
  if (volumeChart) {
    volumeChart.destroy();
  }

  // Calculate bar colors based on price movement
  const barColors = stockData.volume.map((vol, i) =>
    i === 0 ? '#00d4ff' : (stockData.close[i] >= stockData.close[i - 1] ? '#00ff88' : '#ff3366')
  );

  // Build series array - volume bars first (plain array for mixed chart compatibility)
  // Use 'column' type for vertical bars in mixed charts
  const series = [{
    name: 'Volume',
    type: 'column',
    data: stockData.volume
  }];

  // Build stroke widths array
  const strokeWidths = [0];  // No stroke for bars

  // Build colors array for series (first is for bars, rest are for line indicators)
  // Note: Per-bar coloring is handled separately via fill options
  const seriesColors = ['#00d4ff'];  // Default bar color

  // Add selected volume indicators as line series (using backend-calculated data)
  if (indicatorData) {
    selectedVolumeIndicators.forEach(indicatorKey => {
      const config = VOLUME_INDICATOR_CONFIG[indicatorKey];
      // Map frontend key to backend data key (vol_sma_12 -> indicatorData.vol_sma_12)
      const backendData = indicatorData[indicatorKey];

      if (config && backendData) {
        series.push({
          name: config.name,
          type: 'line',
          data: backendData
        });
        strokeWidths.push(2);
        seriesColors.push(config.color);
      }
    });
  }

  const options = {
    series: series,
    chart: {
      type: 'line',  // Base type for mixed charts
      height: 300,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: {
        show: true,
        tools: {
          download: true,
          zoom: true,
          zoomin: true,
          zoomout: true,
          pan: true,
          reset: true
        }
      },
      zoom: {
        enabled: true,
        type: 'x'
      }
    },
    colors: seriesColors,
    stroke: {
      width: strokeWidths,
      curve: 'smooth'
    },
    dataLabels: {
      enabled: false  // Disable data labels for performance
    },
    plotOptions: {
      bar: {
        columnWidth: '95%',
        distributed: false
      }
    },
    fill: {
      colors: [function({ value, seriesIndex, dataPointIndex, w }) {
        if (seriesIndex === 0) {
          // Bar series - use price movement colors
          return barColors[dataPointIndex] || '#00d4ff';
        }
        // Line series - use their configured color
        return seriesColors[seriesIndex] || '#00d4ff';
      }]
    },
    xaxis: {
      type: 'category',
      categories: stockData.dates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        rotateAlways: false,
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => {
          if (!val) return '';
          const parts = val.split('-');
          return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : val;
        }
      }
    },
    yaxis: {
      labels: {
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => {
          if (val >= 1e9) return (val / 1e9).toFixed(1) + 'B';
          if (val >= 1e6) return (val / 1e6).toFixed(1) + 'M';
          if (val >= 1e3) return (val / 1e3).toFixed(1) + 'K';
          return val.toFixed(0);
        }
      }
    },
    grid: {
      borderColor: '#2a3154',
      strokeDashArray: 3
    },
    legend: {
      show: selectedVolumeIndicators.length > 0,
      position: 'top',
      horizontalAlign: 'left',
      fontSize: '14px',
      labels: {
        colors: '#e8eaf6'
      }
    },
    theme: {
      mode: 'dark'
    },
    tooltip: {
      theme: 'dark',
      shared: true,
      intersect: false,
      y: {
        formatter: (val) => val ? val.toLocaleString() : ''
      },
      x: {
        formatter: (val, opts) => stockData.dates[opts.dataPointIndex] || val
      }
    }
  };

  volumeChart = new ApexCharts(document.querySelector("#volumeChart"), options);
  volumeChart.render();
}

function renderRSIChart() {
  // Destroy existing chart if it exists
  if (rsiChart) {
    rsiChart.destroy();
  }

  // Skip if indicators not available
  if (!indicatorData || !indicatorData.rsi) {
    document.querySelector("#rsiChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">Technical indicators not available (TA-Lib required)</p>';
    return;
  }

  // Filter out null/NaN/undefined values and build category-aligned data
  const validDates = [];
  const validRSI = [];
  for (let i = 0; i < indicatorData.rsi.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.dates[i] !== undefined &&
        indicatorData.rsi[i] !== null &&
        indicatorData.rsi[i] !== undefined &&
        !isNaN(indicatorData.rsi[i])) {
      validDates.push(indicatorData.dates[i]);
      validRSI.push(indicatorData.rsi[i]);
    }
  }

  // If no valid data, show message
  if (validDates.length === 0) {
    document.querySelector("#rsiChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid RSI data available (warmup period or data issue)</p>';
    return;
  }

  // Create constant arrays for reference lines
  const oversoldLine = validDates.map(() => 30);
  const overboughtLine = validDates.map(() => 70);

  const options = {
    series: [
      { name: 'RSI', data: validRSI },
      { name: 'Oversold (30)', data: oversoldLine },
      { name: 'Overbought (70)', data: overboughtLine }
    ],
    chart: {
      type: 'line',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: {
        show: true,
        tools: {
          download: true,
          zoom: true,
          zoomin: true,
          zoomout: true,
          pan: true,
          reset: true
        }
      },
      zoom: {
        enabled: true,
        type: 'x'
      }
    },
    colors: ['#00d4ff', '#00ff88', '#ff3366'],
    stroke: {
      width: [3, 2, 2],
      curve: 'smooth',
      dashArray: [0, 5, 5]
    },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        rotateAlways: false,
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => {
          if (!val) return '';
          const parts = val.split('-');
          return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : val;
        }
      }
    },
    yaxis: {
      min: 0,
      max: 100,
      labels: {
        style: {
          colors: '#9fa8da'
        }
      }
    },
    grid: {
      borderColor: '#2a3154',
      strokeDashArray: 3
    },
    legend: {
      position: 'top',
      horizontalAlign: 'left',
      fontSize: '14px',
      labels: {
        colors: '#e8eaf6'
      }
    },
    theme: {
      mode: 'dark'
    },
    tooltip: {
      theme: 'dark',
      shared: true,
      intersect: false,
      x: {
        formatter: (val, opts) => validDates[opts.dataPointIndex] || val
      }
    },
    annotations: {
      yaxis: [
        {
          y: 30,
          borderColor: '#00ff88',
          fillColor: '#00ff88',
          opacity: 0.1
        },
        {
          y: 70,
          borderColor: '#ff3366',
          fillColor: '#ff3366',
          opacity: 0.1
        }
      ]
    }
  };

  rsiChart = new ApexCharts(document.querySelector("#rsiChart"), options);
  rsiChart.render();
}

function renderMACDChart() {
  // Destroy existing chart if it exists
  if (macdChart) {
    macdChart.destroy();
  }

  // Skip if indicators not available
  if (!indicatorData || !indicatorData.macd) {
    document.querySelector("#macdChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">Technical indicators not available (TA-Lib required)</p>';
    return;
  }

  // Filter out null/NaN/undefined values and build category-aligned data
  const validDates = [];
  const validMACD = [];
  const validSignal = [];
  const validHist = [];
  for (let i = 0; i < indicatorData.macd.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.dates[i] !== undefined &&
        indicatorData.macd[i] !== null &&
        indicatorData.macd[i] !== undefined &&
        indicatorData.macd_signal[i] !== null &&
        indicatorData.macd_signal[i] !== undefined &&
        indicatorData.macd_hist[i] !== null &&
        indicatorData.macd_hist[i] !== undefined &&
        !isNaN(indicatorData.macd[i]) &&
        !isNaN(indicatorData.macd_signal[i]) &&
        !isNaN(indicatorData.macd_hist[i])) {
      validDates.push(indicatorData.dates[i]);
      validMACD.push(indicatorData.macd[i]);
      validSignal.push(indicatorData.macd_signal[i]);
      validHist.push(indicatorData.macd_hist[i]);
    }
  }

  // If no valid data, show message
  if (validDates.length === 0) {
    document.querySelector("#macdChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid MACD data available (warmup period or data issue)</p>';
    return;
  }

  // Prepare histogram data with colors for category axis
  const histData = validHist.map(h => ({
    y: h,
    fillColor: h >= 0 ? '#00ff88' : '#ff3366'
  }));

  const options = {
    series: [
      { name: 'Histogram', type: 'bar', data: histData },
      { name: 'MACD', type: 'line', data: validMACD },
      { name: 'Signal', type: 'line', data: validSignal }
    ],
    chart: {
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: {
        show: true,
        tools: {
          download: true,
          zoom: true,
          zoomin: true,
          zoomout: true,
          pan: true,
          reset: true
        }
      },
      zoom: {
        enabled: true,
        type: 'x'
      }
    },
    plotOptions: {
      bar: {
        columnWidth: '80%'
      }
    },
    colors: ['#00ff88', '#00d4ff', '#ffaa00'],
    stroke: {
      width: [0, 3, 3],
      curve: 'smooth'
    },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        rotateAlways: false,
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => {
          if (!val) return '';
          const parts = val.split('-');
          return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : val;
        }
      }
    },
    yaxis: {
      labels: {
        style: {
          colors: '#9fa8da'
        },
        formatter: (val) => val ? val.toFixed(2) : ''
      }
    },
    grid: {
      borderColor: '#2a3154',
      strokeDashArray: 3
    },
    legend: {
      position: 'top',
      horizontalAlign: 'left',
      fontSize: '14px',
      labels: {
        colors: '#e8eaf6'
      }
    },
    theme: {
      mode: 'dark'
    },
    tooltip: {
      theme: 'dark',
      shared: true,
      intersect: false,
      x: {
        formatter: (val, opts) => validDates[opts.dataPointIndex] || val
      }
    }
  };

  macdChart = new ApexCharts(document.querySelector("#macdChart"), options);
  macdChart.render();
}

function renderStochChart() {
  if (stochChart) {
    stochChart.destroy();
  }

  if (!indicatorData || !indicatorData.stoch_slowk || !indicatorData.stoch_slowd) {
    document.querySelector("#stochChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">Stochastic data not available</p>';
    return;
  }

  // Filter valid data points
  const validDates = [];
  const validSlowK = [];
  const validSlowD = [];
  for (let i = 0; i < indicatorData.stoch_slowk.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.stoch_slowk[i] !== null &&
        indicatorData.stoch_slowd[i] !== null &&
        !isNaN(indicatorData.stoch_slowk[i]) &&
        !isNaN(indicatorData.stoch_slowd[i])) {
      validDates.push(indicatorData.dates[i]);
      validSlowK.push(indicatorData.stoch_slowk[i]);
      validSlowD.push(indicatorData.stoch_slowd[i]);
    }
  }

  if (validDates.length === 0) {
    document.querySelector("#stochChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid Stochastic data available</p>';
    return;
  }

  // Create reference lines
  const oversoldLine = validDates.map(() => 20);
  const overboughtLine = validDates.map(() => 80);

  const options = {
    series: [
      { name: '%K', data: validSlowK },
      { name: '%D', data: validSlowD },
      { name: 'Oversold (20)', data: oversoldLine },
      { name: 'Overbought (80)', data: overboughtLine }
    ],
    chart: {
      type: 'line',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: { show: true, tools: { download: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true } },
      zoom: { enabled: true, type: 'x' }
    },
    colors: ['#00d4ff', '#ffaa00', '#00ff88', '#ff3366'],
    stroke: { width: [3, 3, 2, 2], curve: 'smooth', dashArray: [0, 0, 5, 5] },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        style: { colors: '#9fa8da' },
        formatter: (val) => val ? `${val.split('-')[1]}/${val.split('-')[2]}` : ''
      }
    },
    yaxis: { min: 0, max: 100, labels: { style: { colors: '#9fa8da' } } },
    grid: { borderColor: '#2a3154', strokeDashArray: 3 },
    legend: { position: 'top', horizontalAlign: 'left', fontSize: '14px', labels: { colors: '#e8eaf6' } },
    theme: { mode: 'dark' },
    tooltip: { theme: 'dark', shared: true, intersect: false, x: { formatter: (val, opts) => validDates[opts.dataPointIndex] || val } }
  };

  stochChart = new ApexCharts(document.querySelector("#stochChart"), options);
  stochChart.render();
}

function renderCCIChart() {
  if (cciChart) {
    cciChart.destroy();
  }

  if (!indicatorData || !indicatorData.cci_14) {
    document.querySelector("#cciChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">CCI data not available</p>';
    return;
  }

  // Filter valid data points
  const validDates = [];
  const validCCI = [];
  for (let i = 0; i < indicatorData.cci_14.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.cci_14[i] !== null &&
        !isNaN(indicatorData.cci_14[i])) {
      validDates.push(indicatorData.dates[i]);
      validCCI.push(indicatorData.cci_14[i]);
    }
  }

  if (validDates.length === 0) {
    document.querySelector("#cciChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid CCI data available</p>';
    return;
  }

  // Create reference lines
  const upperLine = validDates.map(() => 100);
  const lowerLine = validDates.map(() => -100);
  const zeroLine = validDates.map(() => 0);

  const options = {
    series: [
      { name: 'CCI', data: validCCI },
      { name: 'Overbought (+100)', data: upperLine },
      { name: 'Zero', data: zeroLine },
      { name: 'Oversold (-100)', data: lowerLine }
    ],
    chart: {
      type: 'line',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: { show: true, tools: { download: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true } },
      zoom: { enabled: true, type: 'x' }
    },
    colors: ['#a55eea', '#ff3366', '#9fa8da', '#00ff88'],
    stroke: { width: [3, 2, 1, 2], curve: 'smooth', dashArray: [0, 5, 5, 5] },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        style: { colors: '#9fa8da' },
        formatter: (val) => val ? `${val.split('-')[1]}/${val.split('-')[2]}` : ''
      }
    },
    yaxis: { labels: { style: { colors: '#9fa8da' }, formatter: (val) => val ? val.toFixed(0) : '' } },
    grid: { borderColor: '#2a3154', strokeDashArray: 3 },
    legend: { position: 'top', horizontalAlign: 'left', fontSize: '14px', labels: { colors: '#e8eaf6' } },
    theme: { mode: 'dark' },
    tooltip: { theme: 'dark', shared: true, intersect: false, x: { formatter: (val, opts) => validDates[opts.dataPointIndex] || val } }
  };

  cciChart = new ApexCharts(document.querySelector("#cciChart"), options);
  cciChart.render();
}

function renderADXChart() {
  if (adxChart) {
    adxChart.destroy();
  }

  if (!indicatorData || !indicatorData.adx_14) {
    document.querySelector("#adxChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">ADX data not available</p>';
    return;
  }

  // Filter valid data points
  const validDates = [];
  const validADX = [];
  for (let i = 0; i < indicatorData.adx_14.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.adx_14[i] !== null &&
        !isNaN(indicatorData.adx_14[i])) {
      validDates.push(indicatorData.dates[i]);
      validADX.push(indicatorData.adx_14[i]);
    }
  }

  if (validDates.length === 0) {
    document.querySelector("#adxChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid ADX data available</p>';
    return;
  }

  // Create threshold line (25 = strong trend)
  const thresholdLine = validDates.map(() => 25);

  const options = {
    series: [
      { name: 'ADX', data: validADX },
      { name: 'Strong Trend (25)', data: thresholdLine }
    ],
    chart: {
      type: 'line',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: { show: true, tools: { download: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true } },
      zoom: { enabled: true, type: 'x' }
    },
    colors: ['#fd9644', '#9fa8da'],
    stroke: { width: [3, 2], curve: 'smooth', dashArray: [0, 5] },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        style: { colors: '#9fa8da' },
        formatter: (val) => val ? `${val.split('-')[1]}/${val.split('-')[2]}` : ''
      }
    },
    yaxis: { min: 0, max: 100, labels: { style: { colors: '#9fa8da' } } },
    grid: { borderColor: '#2a3154', strokeDashArray: 3 },
    legend: { position: 'top', horizontalAlign: 'left', fontSize: '14px', labels: { colors: '#e8eaf6' } },
    theme: { mode: 'dark' },
    tooltip: { theme: 'dark', shared: true, intersect: false, x: { formatter: (val, opts) => validDates[opts.dataPointIndex] || val } }
  };

  adxChart = new ApexCharts(document.querySelector("#adxChart"), options);
  adxChart.render();
}

function renderWillrChart() {
  if (willrChart) {
    willrChart.destroy();
  }

  if (!indicatorData || !indicatorData.willr_14) {
    document.querySelector("#willrChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">Williams %R data not available</p>';
    return;
  }

  const validDates = [];
  const validWillr = [];
  for (let i = 0; i < indicatorData.willr_14.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.willr_14[i] !== null &&
        !isNaN(indicatorData.willr_14[i])) {
      validDates.push(indicatorData.dates[i]);
      validWillr.push(indicatorData.willr_14[i]);
    }
  }

  if (validDates.length === 0) {
    document.querySelector("#willrChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid Williams %R data available</p>';
    return;
  }

  // Williams %R reference lines (note: scale is -100 to 0)
  const overboughtLine = validDates.map(() => -20);
  const oversoldLine = validDates.map(() => -80);

  const options = {
    series: [
      { name: 'Williams %R', data: validWillr },
      { name: 'Overbought (-20)', data: overboughtLine },
      { name: 'Oversold (-80)', data: oversoldLine }
    ],
    chart: {
      type: 'line',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: { show: true, tools: { download: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true } },
      zoom: { enabled: true, type: 'x' }
    },
    colors: ['#e056fd', '#ff3366', '#00ff88'],
    stroke: { width: [3, 2, 2], curve: 'smooth', dashArray: [0, 5, 5] },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        style: { colors: '#9fa8da' },
        formatter: (val) => val ? `${val.split('-')[1]}/${val.split('-')[2]}` : ''
      }
    },
    yaxis: { min: -100, max: 0, reversed: true, labels: { style: { colors: '#9fa8da' } } },
    grid: { borderColor: '#2a3154', strokeDashArray: 3 },
    legend: { position: 'top', horizontalAlign: 'left', fontSize: '14px', labels: { colors: '#e8eaf6' } },
    theme: { mode: 'dark' },
    tooltip: { theme: 'dark', shared: true, intersect: false, x: { formatter: (val, opts) => validDates[opts.dataPointIndex] || val } }
  };

  willrChart = new ApexCharts(document.querySelector("#willrChart"), options);
  willrChart.render();
}

function renderATRChart() {
  if (atrChart) {
    atrChart.destroy();
  }

  if (!indicatorData || !indicatorData.atr_14) {
    document.querySelector("#atrChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">ATR data not available</p>';
    return;
  }

  const validDates = [];
  const validATR = [];
  for (let i = 0; i < indicatorData.atr_14.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.atr_14[i] !== null &&
        !isNaN(indicatorData.atr_14[i])) {
      validDates.push(indicatorData.dates[i]);
      validATR.push(indicatorData.atr_14[i]);
    }
  }

  if (validDates.length === 0) {
    document.querySelector("#atrChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid ATR data available</p>';
    return;
  }

  const options = {
    series: [{ name: 'ATR', data: validATR }],
    chart: {
      type: 'area',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: { show: true, tools: { download: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true } },
      zoom: { enabled: true, type: 'x' }
    },
    colors: ['#ff6b6b'],
    fill: { type: 'gradient', gradient: { shadeIntensity: 1, opacityFrom: 0.5, opacityTo: 0.1, stops: [0, 100] } },
    stroke: { width: 3, curve: 'smooth' },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        style: { colors: '#9fa8da' },
        formatter: (val) => val ? `${val.split('-')[1]}/${val.split('-')[2]}` : ''
      }
    },
    yaxis: { labels: { style: { colors: '#9fa8da' }, formatter: (val) => val ? val.toFixed(2) : '' } },
    grid: { borderColor: '#2a3154', strokeDashArray: 3 },
    legend: { position: 'top', horizontalAlign: 'left', fontSize: '14px', labels: { colors: '#e8eaf6' } },
    theme: { mode: 'dark' },
    tooltip: { theme: 'dark', shared: true, intersect: false, x: { formatter: (val, opts) => validDates[opts.dataPointIndex] || val } }
  };

  atrChart = new ApexCharts(document.querySelector("#atrChart"), options);
  atrChart.render();
}

function renderROCChart() {
  if (rocChart) {
    rocChart.destroy();
  }

  if (!indicatorData || !indicatorData.roc_10) {
    document.querySelector("#rocChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">ROC data not available</p>';
    return;
  }

  const validDates = [];
  const validROC = [];
  for (let i = 0; i < indicatorData.roc_10.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.roc_10[i] !== null &&
        !isNaN(indicatorData.roc_10[i])) {
      validDates.push(indicatorData.dates[i]);
      validROC.push(indicatorData.roc_10[i]);
    }
  }

  if (validDates.length === 0) {
    document.querySelector("#rocChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid ROC data available</p>';
    return;
  }

  // Zero line for reference
  const zeroLine = validDates.map(() => 0);

  const options = {
    series: [
      { name: 'ROC', data: validROC },
      { name: 'Zero', data: zeroLine }
    ],
    chart: {
      type: 'line',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: { show: true, tools: { download: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true } },
      zoom: { enabled: true, type: 'x' }
    },
    colors: ['#20bf6b', '#9fa8da'],
    stroke: { width: [3, 1], curve: 'smooth', dashArray: [0, 5] },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        style: { colors: '#9fa8da' },
        formatter: (val) => val ? `${val.split('-')[1]}/${val.split('-')[2]}` : ''
      }
    },
    yaxis: { labels: { style: { colors: '#9fa8da' }, formatter: (val) => val ? val.toFixed(2) + '%' : '' } },
    grid: { borderColor: '#2a3154', strokeDashArray: 3 },
    legend: { position: 'top', horizontalAlign: 'left', fontSize: '14px', labels: { colors: '#e8eaf6' } },
    theme: { mode: 'dark' },
    tooltip: { theme: 'dark', shared: true, intersect: false, x: { formatter: (val, opts) => validDates[opts.dataPointIndex] || val } }
  };

  rocChart = new ApexCharts(document.querySelector("#rocChart"), options);
  rocChart.render();
}

function renderMomentumChart() {
  if (momChart) {
    momChart.destroy();
  }

  if (!indicatorData || !indicatorData.mom_10) {
    document.querySelector("#momChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">Momentum data not available</p>';
    return;
  }

  const validDates = [];
  const validMom = [];
  for (let i = 0; i < indicatorData.mom_10.length; i++) {
    if (indicatorData.dates[i] !== null &&
        indicatorData.mom_10[i] !== null &&
        !isNaN(indicatorData.mom_10[i])) {
      validDates.push(indicatorData.dates[i]);
      validMom.push(indicatorData.mom_10[i]);
    }
  }

  if (validDates.length === 0) {
    document.querySelector("#momChart").innerHTML = '<p style="text-align: center; padding: 40px; color: #9fa8da;">No valid Momentum data available</p>';
    return;
  }

  // Zero line for reference
  const zeroLine = validDates.map(() => 0);

  const options = {
    series: [
      { name: 'Momentum', data: validMom },
      { name: 'Zero', data: zeroLine }
    ],
    chart: {
      type: 'line',
      height: 350,
      group: 'stock-charts',
      background: '#151b3d',
      foreColor: '#e8eaf6',
      toolbar: { show: true, tools: { download: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true } },
      zoom: { enabled: true, type: 'x' }
    },
    colors: ['#f7b731', '#9fa8da'],
    stroke: { width: [3, 1], curve: 'smooth', dashArray: [0, 5] },
    xaxis: {
      type: 'category',
      categories: validDates,
      tickAmount: 10,
      labels: {
        rotate: -45,
        style: { colors: '#9fa8da' },
        formatter: (val) => val ? `${val.split('-')[1]}/${val.split('-')[2]}` : ''
      }
    },
    yaxis: { labels: { style: { colors: '#9fa8da' }, formatter: (val) => val ? '$' + val.toFixed(2) : '' } },
    grid: { borderColor: '#2a3154', strokeDashArray: 3 },
    legend: { position: 'top', horizontalAlign: 'left', fontSize: '14px', labels: { colors: '#e8eaf6' } },
    theme: { mode: 'dark' },
    tooltip: { theme: 'dark', shared: true, intersect: false, x: { formatter: (val, opts) => validDates[opts.dataPointIndex] || val } }
  };

  momChart = new ApexCharts(document.querySelector("#momChart"), options);
  momChart.render();
}

function renderPatternAlerts() {
  const container = document.getElementById('patternAlerts');

  if (!indicatorData || !indicatorData.patterns || indicatorData.patterns.length === 0) {
    container.innerHTML = '<p class="no-alerts"><i class="fas fa-check-circle"></i> No patterns detected in the selected period</p>';
    return;
  }

  let html = '';
  indicatorData.patterns.forEach(pattern => {
    html += `
      <div class="alert-item ${pattern.signal}">
        <div class="alert-info">
          <span class="alert-pattern">${pattern.pattern}</span>
          <span class="alert-date">${pattern.date}</span>
        </div>
        <span class="alert-signal ${pattern.signal}">${pattern.signal}</span>
      </div>
    `;
  });

  container.innerHTML = html;
}

function renderSignalAlerts() {
  const container = document.getElementById('signalAlerts');

  if (!indicatorData) {
    container.innerHTML = '<p class="no-alerts">Loading...</p>';
    return;
  }

  const signals = [];

  // Get latest valid RSI value
  const latestRsi = indicatorData.rsi?.filter(v => v !== null).slice(-1)[0];
  if (latestRsi !== undefined) {
    if (latestRsi < 30) {
      signals.push({ indicator: 'RSI', value: latestRsi.toFixed(1), signal: 'buy', message: 'Oversold territory' });
    } else if (latestRsi > 70) {
      signals.push({ indicator: 'RSI', value: latestRsi.toFixed(1), signal: 'sell', message: 'Overbought territory' });
    } else {
      signals.push({ indicator: 'RSI', value: latestRsi.toFixed(1), signal: 'hold', message: 'Neutral zone' });
    }
  }

  // Get latest Stochastic values
  const latestSlowK = indicatorData.stoch_slowk?.filter(v => v !== null).slice(-1)[0];
  const latestSlowD = indicatorData.stoch_slowd?.filter(v => v !== null).slice(-1)[0];
  if (latestSlowK !== undefined && latestSlowD !== undefined) {
    if (latestSlowK < 20 && latestSlowD < 20) {
      signals.push({ indicator: 'Stochastic', value: `${latestSlowK.toFixed(0)}/${latestSlowD.toFixed(0)}`, signal: 'buy', message: 'Oversold' });
    } else if (latestSlowK > 80 && latestSlowD > 80) {
      signals.push({ indicator: 'Stochastic', value: `${latestSlowK.toFixed(0)}/${latestSlowD.toFixed(0)}`, signal: 'sell', message: 'Overbought' });
    } else if (latestSlowK > latestSlowD && latestSlowK < 50) {
      signals.push({ indicator: 'Stochastic', value: `${latestSlowK.toFixed(0)}/${latestSlowD.toFixed(0)}`, signal: 'buy', message: '%K crossed above %D' });
    } else if (latestSlowK < latestSlowD && latestSlowK > 50) {
      signals.push({ indicator: 'Stochastic', value: `${latestSlowK.toFixed(0)}/${latestSlowD.toFixed(0)}`, signal: 'sell', message: '%K crossed below %D' });
    }
  }

  // Get latest CCI value
  const latestCci = indicatorData.cci_14?.filter(v => v !== null).slice(-1)[0];
  if (latestCci !== undefined) {
    if (latestCci < -100) {
      signals.push({ indicator: 'CCI', value: latestCci.toFixed(0), signal: 'buy', message: 'Oversold' });
    } else if (latestCci > 100) {
      signals.push({ indicator: 'CCI', value: latestCci.toFixed(0), signal: 'sell', message: 'Overbought' });
    }
  }

  // Get latest Williams %R
  const latestWillr = indicatorData.willr_14?.filter(v => v !== null).slice(-1)[0];
  if (latestWillr !== undefined) {
    if (latestWillr < -80) {
      signals.push({ indicator: 'Williams %R', value: latestWillr.toFixed(0), signal: 'buy', message: 'Oversold' });
    } else if (latestWillr > -20) {
      signals.push({ indicator: 'Williams %R', value: latestWillr.toFixed(0), signal: 'sell', message: 'Overbought' });
    }
  }

  // Get latest ADX (trend strength)
  const latestAdx = indicatorData.adx_14?.filter(v => v !== null).slice(-1)[0];
  if (latestAdx !== undefined) {
    if (latestAdx > 25) {
      signals.push({ indicator: 'ADX', value: latestAdx.toFixed(0), signal: 'hold', message: 'Strong trend' });
    } else {
      signals.push({ indicator: 'ADX', value: latestAdx.toFixed(0), signal: 'hold', message: 'Weak/No trend' });
    }
  }

  // MACD crossover
  const macdValues = indicatorData.macd?.filter(v => v !== null);
  const signalValues = indicatorData.macd_signal?.filter(v => v !== null);
  if (macdValues?.length >= 2 && signalValues?.length >= 2) {
    const prevMacd = macdValues[macdValues.length - 2];
    const currMacd = macdValues[macdValues.length - 1];
    const prevSignal = signalValues[signalValues.length - 2];
    const currSignal = signalValues[signalValues.length - 1];

    if (prevMacd < prevSignal && currMacd > currSignal) {
      signals.push({ indicator: 'MACD', value: currMacd.toFixed(2), signal: 'buy', message: 'Bullish crossover' });
    } else if (prevMacd > prevSignal && currMacd < currSignal) {
      signals.push({ indicator: 'MACD', value: currMacd.toFixed(2), signal: 'sell', message: 'Bearish crossover' });
    }
  }

  if (signals.length === 0) {
    container.innerHTML = '<p class="no-alerts"><i class="fas fa-check-circle"></i> No significant signals detected</p>';
    return;
  }

  let html = '';
  signals.forEach(sig => {
    html += `
      <div class="alert-item ${sig.signal === 'buy' ? 'bullish' : sig.signal === 'sell' ? 'bearish' : 'neutral'}">
        <div class="alert-info">
          <span class="alert-pattern">${sig.indicator}: ${sig.value}</span>
          <span class="alert-date">${sig.message}</span>
        </div>
        <span class="alert-signal ${sig.signal}">${sig.signal}</span>
      </div>
    `;
  });

  container.innerHTML = html;
}

function updateChartType(type) {
  currentChartType = type;

  // Update button states
  document.querySelectorAll('[data-chart]').forEach(btn => {
    btn.classList.remove('active');
  });
  document.querySelector(`[data-chart="${type}"]`).classList.add('active');

  // Show/hide indicator selector based on chart type
  const indicatorSelector = document.getElementById('indicatorSelector');
  indicatorSelector.style.display = type === 'line' ? 'flex' : 'none';

  // Re-render chart
  renderPriceChart();
}

function toggleIndicatorDropdown() {
  const menu = document.getElementById('indicatorDropdownMenu');
  menu.classList.toggle('show');
}

function updateSelectedIndicators() {
  const checkboxes = document.querySelectorAll('#indicatorDropdownMenu input[type="checkbox"]');
  selectedIndicators = [];

  checkboxes.forEach(cb => {
    if (cb.checked) {
      selectedIndicators.push(cb.value);
    }
  });

  // Update the count display
  const countEl = document.getElementById('selectedIndicatorCount');
  if (selectedIndicators.length === 0) {
    countEl.textContent = 'None';
  } else if (selectedIndicators.length === 1) {
    countEl.textContent = INDICATOR_CONFIG[selectedIndicators[0]].name;
  } else {
    countEl.textContent = `${selectedIndicators.length} selected`;
  }

  // Re-render the chart if in line mode
  if (currentChartType === 'line') {
    renderPriceChart();
  }
}

function toggleVolumeIndicatorDropdown() {
  const menu = document.getElementById('volumeIndicatorDropdownMenu');
  menu.classList.toggle('show');
}

function updateSelectedVolumeIndicators() {
  const checkboxes = document.querySelectorAll('#volumeIndicatorDropdownMenu input[type="checkbox"]');
  selectedVolumeIndicators = [];

  checkboxes.forEach(cb => {
    if (cb.checked) {
      selectedVolumeIndicators.push(cb.value);
    }
  });

  // Update the count display
  const countEl = document.getElementById('selectedVolumeIndicatorCount');
  if (selectedVolumeIndicators.length === 0) {
    countEl.textContent = 'None';
  } else if (selectedVolumeIndicators.length === 1) {
    countEl.textContent = VOLUME_INDICATOR_CONFIG[selectedVolumeIndicators[0]].name;
  } else {
    countEl.textContent = `${selectedVolumeIndicators.length} selected`;
  }

  // Re-render the volume chart
  renderVolumeChart();
}

// Close dropdowns when clicking outside
document.addEventListener('click', function(event) {
  const priceDropdown = document.querySelector('#indicatorSelector .indicator-dropdown');
  if (priceDropdown && !priceDropdown.contains(event.target)) {
    document.getElementById('indicatorDropdownMenu').classList.remove('show');
  }

  const volumeDropdown = document.querySelector('#volumeIndicatorDropdownMenu')?.closest('.indicator-dropdown');
  if (volumeDropdown && !volumeDropdown.contains(event.target)) {
    document.getElementById('volumeIndicatorDropdownMenu').classList.remove('show');
  }
});

async function runStrategyComparison() {
  const resultsDiv = document.getElementById('strategyResults');
  resultsDiv.innerHTML = '<p class="loading"><i class="fas fa-spinner fa-spin"></i> Running backtests...</p>';

  try {
    const response = await fetch(`/api/compare/${ticker}`, { method: 'POST' });
    const results = await response.json();

    let html = '<table class="results-table"><thead><tr>';
    html += '<th>Strategy</th><th>Return</th><th>Sharpe</th><th>Drawdown</th><th>Win Rate</th><th>Trades</th>';
    html += '</tr></thead><tbody>';

    results.forEach((result, i) => {
      const returnClass = result.return >= 0 ? 'positive' : 'negative';
      const rank = i === 0 ? '<i class="fas fa-trophy" style="color: #FFD700;"></i> ' : '';
      html += `<tr>
        <td>${rank}${result.strategy}</td>
        <td class="${returnClass}">${result.return.toFixed(2)}%</td>
        <td>${result.sharpe.toFixed(2)}</td>
        <td>${result.drawdown.toFixed(2)}%</td>
        <td>${result.win_rate.toFixed(2)}%</td>
        <td>${result.trades}</td>
      </tr>`;
    });

    html += '</tbody></table>';
    resultsDiv.innerHTML = html;
  } catch (error) {
    console.error('Error comparing strategies:', error);
    resultsDiv.innerHTML = '<p class="error">Failed to compare strategies. Please try again.</p>';
  }
}

async function updatePeriod(period) {
  currentPeriod = period;

  // Update button states
  document.querySelectorAll('[data-period]').forEach(btn => {
    btn.classList.remove('active');
  });
  document.querySelector(`[data-period="${period}"]`).classList.add('active');

  // Reload data with new period
  await loadStockData();
  await loadIndicators();
}

function refreshData() {
  location.reload();
}
</script>
